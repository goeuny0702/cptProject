[
    {
        "id": 1,
        "question": "시스템 카탈로그에 대한 설명으로 옳지 않은 것은?",
        "options": [
            "시스템 자체에 관련 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스이다.",
            "카탈로그들이 생성되면 자료 사전에 저장되기 때문에 좁은 의미로는 자료 사전이라고도 한다.",
            "무결성 확보를 위하여 일반 사용자는 내용을 검색할 수 없다.",
            "기본 테이블, 뷰, 인덱스, 패키지, 접근 권한 등의 정보를 저장한다."
        ],
        "correct": 3,
        "solution": "시스템 카탈로그(System Catalog)는 DBMS가 자동으로 생성하고 관리하는 데이터 사전으로, 테이블, 뷰, 인덱스, 사용자, 권한 등의 정보를 저장함."
    },
    {
        "id": 2,
        "question": "테이블, 뷰, 인덱스 제거 시 사용하는 명령문은?",
        "options": [
            "CREATE 문",
            "DROP 문",
            "ALERT 문",
            "CLOSE 문"
        ],
        "correct": 2,
        "solution": "테이블 삭제 → DROP TABLE 테이블명, 뷰 삭제 → DROP VIEW 뷰명, 인덱스 삭제 → DROP INDEX 인덱스명"
    },
    {
        "id": 3,
        "question": "관계해석에 대한 설명으로 틀린 것은?",
        "options": [
            "관계 데이터의 연산을 표현하는 방법이다.",
            "원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적인 언어이다.",
            "튜플 관계해석과 도메인 관계해석이 있다.",
            "관계대수로 표현한 식은 관계해석으로 표현할 수 있다."
        ],
        "correct": 2,
        "solution": "관계해석(Relational Calculus)은 비절차적(Non-Procedural) 질의 언어이며, 어떤 데이터를 원하는지 명시하지만 '어떻게 구하는지'는 명시하지 않음."
    },
    {
        "id": 4,
        "question": "트랜잭션의 특성 중 “all or nothing”, 즉 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 함을 의미하는 특성은?",
        "options": [
            "atomicity",
            "consistency",
            "isolation",
            "durability"
        ],
        "correct": 1,
        "solution": "트랜잭션(Transaction)의 4가지 특성(ACID) 중 **원자성(Atomicity)**은 **'모두 수행되거나, 전혀 수행되지 않음'**을 보장."
    },
    {
        "id": 5,
        "question": "데이터베이스 3단계 구조 중 사용자나 응용프로그래머가 사용할 수 있도록 데이터베이스를 정의한 것은?",
        "options": [
            "외부 스키마(External Schema)",
            "개념 스키마(Conceptual Schema)",
            "내부 스키마(Internal Schema)",
            "관계 스키마(Relational Schema)"
        ],
        "correct": 1,
        "solution": "외부 스키마: 사용자나 응용 프로그램이 접근할 수 있도록 정의한 부분 (사용자 관점)"
    },
    {
        "id": 6,
        "question": "데이터베이스 물리적 설계의 옵션 선택시 고려사항으로 거리가 먼 것은?",
        "options": [
            "트랜잭션 처리량",
            "공간 활용도",
            "응용프로그램의 양",
            "응답 시간"
        ],
        "correct": 3,
        "solution": "물리적 설계 시 고려하는 요소는 다음과 같음. 접근 경로(인덱스), 성능(응답 속도), 저장 공간, 트랜잭션 처리량"
    },
    {
        "id": 7,
        "question": "데이터베이스 설계 단계 중 논리적 설계 단계에 해당하는 것은?",
        "options": [
            "개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계한다.",
            "데이터베이스 파일의 저장 구조 및 액세스 경로를 결정한다.",
            "물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정이다.",
            "저장 레코드의 형식, 순서, 접근 경로 등의 정보가 컴퓨터에 저장되는 방법을 묘사한다."
        ],
        "correct": 1,
        "solution": "관계 데이터 모델 변환"
    },
    {
        "id": 8,
        "question": "정렬 알고리즘 선택시 고려하여야 할 사항으로 거리가 먼 것은?",
        "options": [
            "데이터의 양",
            "초기 데이터의 배열상태",
            "키 값들의 분포상태",
            "운영체제의 종류"
        ],
        "correct": 4,
        "solution": "데이터의 논리적 모델"
    },
    {
        "id": 9,
        "question": "입력 데이터가 R = (71, 2, 38, 5, 7, 61, 11, 26, 53, 42)일 때 2-Way Merge Sort를 2회전한 후 결과는?",
        "options": [
            "R = (2, 5, 38, 71, 7, 11, 26, 61, 42, 53)",
            "R = (71, 2, 5, 38, 7, 61, 11, 26, 42, 53)",
            "R = (5, 2, 7, 11, 26, 38, 61, 71, 42, 53)",
            "R = (2, 5, 7, 11, 26, 38, 42, 53, 71, 61)"
        ],
        "correct": 1,
        "solution": "(2, 5, 38, 71, 7, 11, 26, 61, 42, 53)"
    },
    {
        "id": 10,
        "question": "n개의 원소를 정렬하는 방법 중 평균 수행시간 복잡도와 최악 수행시간 복잡도가 모두 O(nlog2n)인 정렬은?",
        "options": [
            "삽입 정렬",
            "힙 정렬",
            "버블 정렬",
            "선택 정렬"
        ],
        "correct": 2,
        "solution": "병합 정렬, 힙 정렬"
    },
    {
        "id": 11,
        "question": "정규화의 원칙으로 거리가 먼 것은?",
        "options": [
            "하나의 스키마에서 다른 스키마로 변환시킬 때 정보의 손실이 있어서는 안 된다.",
            "이상현상 제거를 위해 데이터의 종속성이 많아야 한다.",
            "하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현한다.",
            "데이터의 중복성이 감소되어야 한다."
        ],
        "correct": 2,
        "solution": "정규화(Normalization)는 데이터베이스의 중복을 최소화하고, 데이터 무결성을 보장하는 과정입니다."
    },
    {
        "id": 12,
        "question": "관계를 맺고 있는 릴레이션 R1, R2에서 릴레이션 R1이 참조하고 있는 릴레이션 R2의 기본키와 같은 R1 릴레이션의 속성을 무엇이라 하는가?",
        "options": [
            "후보 키(Candidate Key)",
            "외래 키(Foreign Key)",
            "슈퍼 키(Super Key)",
            "대체 키(Alternate Key)"
        ],
        "correct": 3,
        "solution": "**외래키 (Foreign Key)**는 한 릴레이션의 속성이 다른 릴레이션의 기본키를 참조할 때 사용됩니다."
    },
    {
        "id": 13,
        "question": "릴레이션의 기본키를 구성하는 어떤 속성도 널(Null) 값이나 중복 값을 가질 수 없음을 의미하는 것은?",
        "options": [
            "참조 무결성 제약조건",
            "정보 무결성 제약조건",
            "개체 무결성 제약조건",
            "주소 무결성 제약조건"
        ],
        "correct": 3,
        "solution": "기본키로 지정된 속성은 널 값(NULL)을 가질 수 없으며, 중복 값도 허용되지 않습니다."
    },
    {
        "id": 14,
        "question": "E-R 다이어그램에서 개체를 의미하는 기호는?",
        "options": [
            "사각형",
            "오각형",
            "삼각형",
            "타원"
        ],
        "correct": 1,
        "solution": "**개체(Entity)**는 E-R 다이어그램에서 사각형으로 나타냅니다."
    },
    {
        "id": 15,
        "question": "하드웨어 우선순위 인터럽의 특징으로 틀린 것은?",
        "options": [
            "가격이 비싸다.",
            "유연성이 있다.",
            "응답속도가 빠르다.",
            "하드웨어로 우선순위를 결정한다."
        ],
        "correct": 2,
        "solution": "하드웨어 우선순위 인터럽트는 하드웨어적으로 우선순위가 결정되며, 소프트웨어에서 이를 변경할 수 없습니다."
    },
    {
        "id": 16,
        "question": "IEEE754에서 규정한 부동소수점 표현 방법에서 비트 형식에 해당하지 않는 것은?",
        "options": [
            "가수",
            "부호",
            "지수",
            "소수점"
        ],
        "correct": 4,
        "solution": "IEEE 754 표준은 부동소수점 숫자를 표현하는 방법에 대해 정의하고 있으며, 두 가지 주요 형식이 있습니다:"
    },
    {
        "id": 17,
        "question": "누산기에 관한 설명 중 옳은 것은?",
        "options": [
            "기억 장치의 일부이다.",
            "제어기능을 수행한다.",
            "보조기억장치에 포함되어 있다.",
            "연산한 결과를 임시 저장하는 곳이다."
        ],
        "correct": 4,
        "solution": "누산기는 연산의 중간 결과를 저장하는 레지스터이다."
    },
    {
        "id": 18,
        "question": "8bit register의 데이터가 00101001 이다. 이 데이터를 4배 증가시키려고 할 때 취하는 연산 명령은?",
        "options": [
            "Shift Left 4회",
            "Shift Left 2회",
            "Shift Right 4회",
            "Shift Right 2회"
        ],
        "correct": 2,
        "solution": "왼쪽 시프트는 이진수를 왼쪽으로 이동시키며, 한 번 왼쪽으로 이동할 때마다 값이 2배씩 증가합니다."
    },
    {
        "id": 19,
        "question": "AND 연산을 이용하여 어느 비트(문자)를 지울 것인가를 결정하는 것은?",
        "options": [
            "캐리(carry)",
            "플립플롭",
            "패리티(parity) 비트",
            "마스크(mask) 비트"
        ],
        "correct": 4,
        "solution": "AND 연산은 특정 비트를 0으로 설정하려고 할 때 사용합니다."
    },
    {
        "id": 20,
        "question": "인터럽트의 발생 원인으로 틀린 것은?",
        "options": [
            "정전",
            "서브 프로그램 호출",
            "오버플로우(overflow) 발생",
            "오퍼레이터(operator)의 조작"
        ],
        "correct": 2,
        "solution": "CPU가 명령을 수행할 때 발생하는 오류는 **오류 처리(exception)**에 해당하며, 이는 인터럽트와는 다른 개념입니다."
    },
    {
        "id": 21,
        "question": "인터럽트 처리 과정 중 인터럽트 요청한 장치를 차례대로 검사하는 방식은?",
        "options": [
            "폴링",
            "핸드세이킹",
            "데이지 체인",
            "벡터 인터럽트"
        ],
        "correct": 1,
        "solution": "**폴링(Polling)**은 CPU가 주기적으로 각 장치의 인터럽트 요청을 차례대로 검사하는 방식입니다."
    },
    {
        "id": 22,
        "question": "명령(Instruction) 중에서 PC←X 와 같은 의미를 뜻하는 것은?",
        "options": [
            "JMP X",
            "ADD X",
            "MOV X",
            "STA X"
        ],
        "correct": 1,
        "solution": "**PC (Program Counter)**는 실행 중인 프로그램의 다음 명령어 주소를 저장하는 레지스터입니다."
    },
    {
        "id": 23,
        "question": "CAM(Content Addressable Memory)의 특징으로 옳은 것은?",
        "options": [
            "하드웨어 비용이 대단히 적다.",
            "주소 공간의 확대가 목적이다.",
            "구조 및 동작이 대단히 간단하다.",
            "저장된 정보의 내용 자체로 검색한다."
        ],
        "correct": 4,
        "solution": "**CAM (Content Addressable Memory)**는 데이터를 검색할 때 주소가 아니라 데이터 자체를 이용하여 검색하는 메모리입니다."
    },
    {
        "id": 24,
        "question": "7bit 코드에서 정보 전송 시에 발생하는 오류의 검색이 용이한 코드는?",
        "options": [
            "2421 code",
            "excess-3 code",
            "biquinary code",
            "8421 code"
        ],
        "correct": 3,
        "solution": "7비트 정보 코드에서 추가된 비트들이 오류를 찾아내고, 수정할 수 있도록 설계되어 있으며, 이를 통해 데이터 전송 중 발생한 오류를 쉽게 탐지하고 수정할 수 있습니다."
    },
    {
        "id": 25,
        "question": "2진수 1010(2)을 그레이 코드로 변환하면?",
        "options": [
            "1010",
            "0101",
            "1111",
            "0000"
        ],
        "correct": 3,
        "solution": "그레이 코드로는 1111이 됩니다."
    },
    {
        "id": 26,
        "question": "8×2 RAM을 이용하여 16×4 메모리를 구성하고자 한다. 몇 개의 8×2 RAM이 필요한가?",
        "options": [
            "2",
            "4",
            "8",
            "16"
        ],
        "correct": 2,
        "solution": "8×2 RAM은 8개의 주소 공간과 각 주소마다 2비트의 데이터를 저장할 수 있는 RAM입니다."
    },
    {
        "id": 27,
        "question": "64K인 주소공간과 4K인 기억공간을 가진 PC인 경우 한 페이지(Page)가 512워드라면 블록의 개수와 블록 주소 비트는?",
        "options": [
            "8개, 3비트",
            "16개, 4비트",
            "32개, 5비트",
            "64개, 6비트"
        ],
        "correct": 1,
        "solution": "각 블록을 식별하려면 블록 주소 비트가 필요합니다. 128개 블록을 식별하려면 log2(128) = 7 비트가 필요합니다."
    },
    {
        "id": 28,
        "question": "Cycle Stealing에 대한 설명으로 옳은 것은?",
        "options": [
            "CPU가 메모리를 접근할 때 사용된다.",
            "I/O controller가 task의 완료를 CPU에 알리는 것이다.",
            "외부 입력의 속도와 CPU의 속도를 맞추기 위해 사용된다.",
            "주변장치가 기억장치를 접근할 때 CPU가 기억장치를 접근하지 못하게 하는 것이다."
        ],
        "correct": 4,
        "solution": "Cycle Stealing은 **DMA (Direct Memory Access)**에서 사용하는 기법으로, CPU가 한 사이클 동안 연산을 수행하는 동안 DMA가 버스를 사용하여 데이터를 전송하는 방식입니다."
    },
    {
        "id": 29,
        "question": "SRAM에 대한 설명으로 틀린 것은?",
        "options": [
            "DRAM에 비해 회로의 집적도가 낮다.",
            "DRAM에 비해 가격이 비싸다.",
            "일정한 시간마다 재충전이 필요하다.",
            "DRAM에 비해 전력 소모가 크다."
        ],
        "correct": 3,
        "solution": "**SRAM (Static RAM)**은 빠른 속도와 더 낮은 전력 소모를 특징으로 하는 메모리입니다."
    },
    {
        "id": 30,
        "question": "MAR(Memory Address Register)의 역할 중 가장 옳은 것은?",
        "options": [
            "수행되어야 할 프로그램의 주소를 가리킨다.",
            "메모리에 보관된 내용을 누산기에 전달하는 역할을 한다.",
            "고급 수준 언어를 기계어로 변환해 주는 일종의 소프트웨어이다.",
            "CPU에서 기억장치 내의 특정 번지에 있는 데이터나 명령어를 인출하기 위해 그 번지를 기억하는 역할을 한다."
        ],
        "correct": 4,
        "solution": "CPU가 메모리에서 데이터를 읽거나 쓸 때 어떤 주소에서 데이터를 가져올지 결정하는 중요한 역할을 합니다."
    },
    {
        "id": 31,
        "question": "명령어 사이클(Instruction Cycle)에 해당하지 않는 것은?",
        "options": [
            "Fetch Cycle",
            "Control Cycle",
            "Indirect Cycle",
            "Interrupt Cycle"
        ],
        "correct": 2,
        "solution": "명령어 사이클은 명령어를 가져오고(Fetch), 해석하고(Decode), 실행하는(Execute) 과정으로 구성됩니다. 레지스터 초기화는 명령어 사이클에 포함되지 않으며, 시스템 초기화 등에서 발생할 수 있습니다."
    },
    {
        "id": 32,
        "question": "마이크로 오퍼레이션 수행에 필요한 시간은?",
        "options": [
            "Search time",
            "Seek time",
            "Access time",
            "CPU clock time"
        ],
        "correct": 4,
        "solution": "마이크로 오퍼레이션은 CPU 내부에서 수행되는 작은 작업으로, 각각의 마이크로 오퍼레이션은 하나의 클록 주기 동안 수행됩니다. 따라서 마이크로 오퍼레이션 수행에 필요한 시간은 클록 주기로 정의됩니다."
    },
    {
        "id": 33,
        "question": "시스템 오류 검사 기법 중 수신한 데이터를 송신 측으로 되돌려 보내 원래의 데이터와 비교하여 오류 여부를 검사하는 방법은?",
        "options": [
            "Balance Check",
            "Range Check",
            "Limit Check",
            "Echo Check"
        ],
        "correct": 4,
        "solution": "Echo Check는 수신한 데이터를 송신 측으로 되돌려 보낸 후 원래의 데이터와 비교하여 오류 여부를 검사하는 기법입니다."
    },
    {
        "id": 34,
        "question": "프로세스 설계에 대한 설명과 거리가 먼 것은?",
        "options": [
            "입력 정보를 이용하여 출력 정보를 생성하는 과정",
            "사용하는 하드웨어 및 소프트웨어의 성능과 무관하게 설계",
            "프로세스 흐름도를 작성한 후 그 내용에 따라 각각의 프로세스의 논리를 설계",
            "시스템의 성능을 고려한 효율적인 처리과정을 표현"
        ],
        "correct": 2,
        "solution": "프로세스 설계는 소프트웨어 설계의 일환으로, 하드웨어 설계와는 별개의 과정입니다. 프로세스 설계는 시스템에서 실행되는 작업들을 어떻게 나누고, 상호작용하는지 등을 정의하는 과정입니다."
    },
    {
        "id": 35,
        "question": "자료 사전에서 사용되는 기호 중 자료 항목이 생략될 수도 있음을 나타내는 기호는?",
        "options": [
            "( )",
            "#",
            "&",
            "!"
        ],
        "correct": 1,
        "solution": "자료 사전에서 **물음표(?)**는 특정 자료 항목이 생략될 수 있음을 나타냅니다."
    },
    {
        "id": 36,
        "question": "IPT(Improved Programming Technique) 기법에 대한 설명과 거리가 먼 것은?",
        "options": [
            "프로그램 생산성 향상을 위해 이용되는 기법을 총칭한다.",
            "HIPO, N-S Chart 등의 도구가 효과적으로 활용될 수 있다.",
            "프로그래밍에 GOTO문을 주로 활용한다.",
            "프로그램의 품질을 향상시켜 유지보수를 용이하게 한다."
        ],
        "correct": 3,
        "solution": "IPT는 기존의 프로그래밍 방법을 개선하기 위해, 알고리즘 개선이나 코드 최적화 기법을 활용하는 기법입니다. 새로운 언어나 도구를 사용하는 것이 아니라 기존의 기술을 개선하는 데 중점을 둡니다."
    },
    {
        "id": 37,
        "question": "객체지향 분석 및 설계 방법과 거리가 먼 것은?",
        "options": [
            "럼바우(Rumbaugh) 분석 모델",
            "코드(Coad)와 요돈(Yourdon) 기법",
            "부치(Booch) 기법",
            "나시-슈나이더만(Nassi-Schneiderman) 기법"
        ],
        "correct": 4,
        "solution": "객체지향 분석 및 설계는 객체와 클래스를 중심으로 시스템을 설계하고 분석합니다. 반면, 절차적 프로그래밍은 함수와 절차 중심으로 문제를 해결하는 방식입니다."
    },
    {
        "id": 38,
        "question": "소프트웨어 개발 단계 중 요구 분석에 대한 설명으로 옳지 않은 것은?",
        "options": [
            "자료 수집 → 요구 사항 도출 → 문서화 → 검증의 절차를 거친다.",
            "소프트웨어의 기능, 성능, 제약 조건 등에 대하여 기술하고 검토한다.",
            "요구 사항은 기능적 요구 사항과 비기능적 요구사항, 사용자 요구 사항과 시스템 요구 사항 등으로 분류된다.",
            "요구 분석 명세서의 정확성을 검증하기 위해 화이트박스 테스트를 수행한다."
        ],
        "correct": 4,
        "solution": "요구 분석은 소프트웨어 개발 초기 단계에서 사용자 요구사항을 수집하고 분석하는 과정입니다. 따라서 개발 후반에 수행되지 않습니다."
    },
    {
        "id": 39,
        "question": "다음 중 객체지향언어가 아닌 것은?",
        "options": [
            "C++",
            "Smalltalk",
            "Ada",
            "COBOL"
        ],
        "correct": 4,
        "solution": "C는 절차적 언어로 객체지향 기능을 제공하지 않습니다. 반면, Java, C++, Python 등은 객체지향 언어입니다."
    },
    {
        "id": 40,
        "question": "코드 설계 시 유의 사항으로 적절하지 않은 것은?",
        "options": [
            "사람의 이용에 우선하여 취급이 쉽고 컴퓨터 처리에 적합해야 한다.",
            "코드 부여 대상의 증감에 대비한 확장성이 있어야 한다.",
            "대상 자료와 일대일로 대응되도록 고유성을 고려하여 설계해야 한다.",
            "가능한 많은 자릿수로 많은 항목을 표현해야 한다."
        ],
        "correct": 4,
        "solution": "코드 설계는 모듈화와 점진적인 설계를 중심으로 진행해야 하며, 한 번에 전체 시스템을 설계하는 것은 비효율적이고 오류를 유발할 수 있습니다."
    },
    {
        "id": 41,
        "question": "럼바우(Rumbaugh)의 객체지향 분석 기법에서 자료 흐름도가 활용되는 모델링 단계는?",
        "options": [
            "객체 모델링",
            "기능 모델링",
            "정적 모델링",
            "동적 모델링"
        ],
        "correct": 2,
        "solution": "럼바우의 객체지향 분석 기법(OOM, Object-Oriented Modeling)에서는 객체 모델링(Object Modeling), 동적 모델링(Dynamic Modeling), **기능 모델링(Functional Modeling)**의 3단계로 나뉩니다."
    },
    {
        "id": 42,
        "question": "정보처리 업무의 표준 처리 패턴 유형 중 2개 이상의 파일에서 조건에 맞는 것을 골라 새로운 레코드로 파일을 만드는 방법은?",
        "options": [
            "분배",
            "추출",
            "정렬",
            "조합"
        ],
        "correct": 4,
        "solution": "**조인(Join)**은 여러 개의 파일에서 특정 조건을 만족하는 데이터를 선택하여 새로운 레코드로 구성하는 방식입니다."
    },
    {
        "id": 43,
        "question": "자료 흐름도(DFD)에 대한 설명으로 옳지 않은 것은?",
        "options": [
            "구조적 분석용 문서화 도구",
            "도형 중심의 표현",
            "상향식 분할의 표현",
            "자료 흐름 중심의 표현"
        ],
        "correct": 3,
        "solution": "자료 흐름도(DFD)는 시스템 내에서 데이터의 흐름과 변환 과정을 시각적으로 표현하는 도구이며, 시간의 흐름을 직접적으로 표현하지 않습니다."
    },
    {
        "id": 44,
        "question": "시스템의 기본 요소로 적절하지 않은 것은?",
        "options": [
            "입력",
            "처리",
            "명세",
            "제어"
        ],
        "correct": 3,
        "solution": "시스템은 입력, 출력, 프로세스, 피드백(FeedBack), 환경 등의 요소로 구성됩니다."
    },
    {
        "id": 45,
        "question": "시간의 흐름에 따른 시스템의 변화상을 보여주는 상태 다이어그램을 작성하는 모형화 단계는?",
        "options": [
            "객체 모형화(object modeling)",
            "동적 모형화(dynamic modeling)",
            "기능 모형화(function modeling)",
            "정적 모형화(static modeling)"
        ],
        "correct": 2,
        "solution": "동적 모델링에서는 시스템의 동적인 변화 상태를 다이어그램으로 표현하며, 주로 **상태 다이어그램(State Diagram)**을 사용합니다."
    },
    {
        "id": 46,
        "question": "거래내역이나 변동 내용 등 일시적인 성격을 지닌 정보를 기록하는 파일로 마스터 파일을 갱신하거나 조회하기 위하여 만들어지는 파일은?",
        "options": [
            "히스토리 파일(History File)",
            "트레일러 파일(Trailer File)",
            "원시 파일(Source File)",
            "트랜잭션 파일(Transaction File)"
        ],
        "correct": 4,
        "solution": "트랜잭션 파일은 일시적인 데이터 저장소로, 마스터 파일을 갱신하거나 조회할 때 사용됩니다."
    },
    {
        "id": 47,
        "question": "구조적 설계의 평가 기준 중 모듈 응집도가 강한 것에서 약한 것의 순서로 옳게 나열된 것은?",
        "options": [
            "절차적 응집도 → 통신적 응집도 → 순차적 응집도 → 기능적 응집도",
            "통신적 응집도 → 절차적 응집도 → 순차적 응집도 → 기능적 응집도",
            "절차적 응집도 → 통신적 응집도 → 기능적 응집도 → 순차적 응집도",
            "기능적 응집도 → 순차적 응집도 → 통신적 응집도 → 절차적 응집도"
        ],
        "correct": 4,
        "solution": "응집도는 모듈의 독립성과 관련되며, 높을수록 좋은 설계입니다."
    },
    {
        "id": 48,
        "question": "테스트 단계 중 시스템을 당장 사용할 수 있도록 준비되어 있는지 확인하기 위한 단계로, 베타 테스트가 포함된 테스트 단계는?",
        "options": [
            "단위모듈 테스트",
            "통합 테스트",
            "시스템 테스트",
            "인수 테스트"
        ],
        "correct": 4,
        "solution": "**인수 테스트(AT)**는 소프트웨어가 실제 운영 환경에서 정상적으로 작동하는지 최종적으로 검증하는 과정으로, 알파 테스트, 베타 테스트가 포함됩니다."
    },
    {
        "id": 49,
        "question": "자료 사전에서 사용되는 기호 중 주석을 의미하는 것은?",
        "options": [
            "{ }",
            "* *",
            "=",
            "+"
        ],
        "correct": 2,
        "solution": "자료 사전에서 **중괄호({})**는 주석(Comment)을 의미하며, 데이터 항목에 대한 설명을 추가하는 데 사용됩니다."
    },
    {
        "id": 50,
        "question": "시스템과 그 시스템 내의 자료에 대한 정보의 무결성과 안정성을 어떻게 보장할 것인지에 관련된 사항을 의미하는 것은?",
        "options": [
            "보호",
            "보안",
            "침투",
            "해킹"
        ],
        "correct": 2,
        "solution": "시스템 보안(Security)은 데이터의 무결성(Integrity)과 안정성(Stability)을 유지하고 보호하는 것을 의미합니다."
    }
]